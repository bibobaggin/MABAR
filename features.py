import csv, os
from datetime import datetime # For cetak_antrian formatting
from linked_queue import LinkedListQueue # type: ignore # Assuming queue.py is in the same directory
from logger import log_activity
from utils import USER_DB, get_display_name


class Antrian:
    def __init__(self, file_name="antrian.txt"):
        self.file_name = file_name
        self.antrian = LinkedListQueue()
        self.load_antrian()

    def masuk_prioritas(self, nama, actor_username=None, actor_role=None): # Added actor info for logging
        # Timestamp will be generated by queue.enqueue_prioritas
        self.antrian.enqueue_prioritas(nama)
        display_name = get_display_name(nama)
        print(f"{display_name} ({nama}) berhasil dimasukkan sebagai prioritas ke depan antrean.")
        self.save_antrian()
        # Logging should ideally be done by the caller (menu function) which knows the actor
        if actor_username and actor_role:
            log_activity(actor_username, actor_role, "Memberi prioritas", f"Pengguna: {nama} ({display_name})")
        else: # Fallback if actor info not provided (less ideal)
            log_activity(nama, "system", "Diberi prioritas")


    def load_antrian(self):
        # When loading from file, timestamp will be the time of loading.
        # The file itself doesn't store timestamps in this version.
        if self.file_name.endswith(".txt"):
            if os.path.exists(self.file_name):
                with open(self.file_name, "r") as f:
                    for line in f:
                        self.antrian.enqueue(line.strip()) # Enqueue will add current time
        elif self.file_name.endswith(".csv"):
            if os.path.exists(self.file_name):
                with open(self.file_name, mode="r", newline='') as f:
                    reader = csv.reader(f)
                    for row in reader:
                        if row:
                            self.antrian.enqueue(row[0]) # Enqueue will add current time

    def save_antrian(self):
        # Saves only usernames to keep file format simple. Timestamps are session-based.
        with open(self.file_name, mode="w", newline='') as f:
            current = self.antrian.front
            if self.file_name.endswith(".txt"):
                while current:
                    f.write(current.data[0] + "\\n") # Save only the username
                    current = current.next
            elif self.file_name.endswith(".csv"):
                writer = csv.writer(f)
                while current:
                    writer.writerow([current.data[0]]) # Save only the username
                    current = current.next

    def cek_antrian(self):
        self.antrian.display()

    def masuk_ke_antrean(self, username, actor_username=None, actor_role=None): # Added actor info for logging
        # Timestamp will be generated by queue.enqueue
        self.antrian.enqueue(username)
        display_name = get_display_name(username)
        # Confirmation often printed by enqueue or handled by menu if exists
        # print(f"{display_name} ({username}) berhasil masuk ke antrean.")
        self.save_antrian()
        if actor_username and actor_role:
             log_activity(actor_username, actor_role, "Masuk antrean", f"Pengguna: {username} ({display_name})")
        else: # Fallback if called directly without actor context
            log_activity(username, "user", "Masuk antrean (self)")


    def keluar_dari_antrean(self, username_to_remove, actor_username=None, actor_role=None): # Added actor info
        display_name = get_display_name(username_to_remove)
        if self.antrian.remove_item(username_to_remove):
            print(f"Pengguna {display_name} ({username_to_remove}) berhasil keluar dari antrean.")
            self.save_antrian()
            if actor_username and actor_role:
                log_activity(actor_username, actor_role, "Keluar dari antrean", f"Pengguna: {username_to_remove} ({display_name})")
            else: # Fallback
                 log_activity(username_to_remove, "user", "Keluar dari antrean (self)")
            return True
        else:
            print(f"Pengguna {display_name} ({username_to_remove}) tidak ditemukan dalam antrean.")
            return False

    def proses_antrean_berikutnya(self, actor_username, actor_role): # Added actor info
        if self.antrian.is_empty():
            print("Antrean kosong, tidak ada yang bisa diproses.")
            return None

        data_tuple = self.antrian.dequeue()
        if data_tuple:
            removed_user_username = data_tuple[0]
            removed_user_join_time = data_tuple[1]
            display_name = get_display_name(removed_user_username)
            
            print(f"Memproses: {display_name} ({removed_user_username})")
            print(f"Bergabung pada: {removed_user_join_time.strftime('%Y-%m-%d %H:%M:%S') if removed_user_join_time else 'N/A'}")
            
            self.save_antrian()
            log_activity(actor_username, actor_role, "Memproses pengguna", f"Pengguna: {removed_user_username} ({display_name})")
            return removed_user_username # Or data_tuple if needed
        return None

    def cetak_antrian(self): # Primary function to modify
        if self.antrian.is_empty():
            print("\nðŸ“­ Antrean kosong! Tidak ada laporan untuk dicetak.\n")
            return

        report_file_name = "laporan_antrian.txt"
        print(f"\nðŸ“„ Mencetak Laporan Antrian ke Konsol dan File ({report_file_name})...")
        
        header = f"{'No.':<5} {'Nama':<25} {'Username':<20} {'Waktu Masuk':<20}"
        separator = "-" * (5 + 25 + 20 + 20 + 9) # Adjusted length

        print("\n" + header)
        print(separator)

        try:
            with open(report_file_name, "w", encoding="utf-8") as f:
                f.write("Laporan Antrian Bank\n")
                f.write(f"Dicetak pada: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write(header + "\n")
                f.write(separator + "\n")

                current = self.antrian.front
                idx = 1
                while current:
                    username, join_time = current.data # Unpack the tuple
                    display_name_val = get_display_name(username)
                    
                    time_str = "N/A"
                    if isinstance(join_time, datetime):
                        time_str = join_time.strftime("%Y-%m-%d %H:%M:%S")
                    
                    line_data = f"{idx:<5} {display_name_val:<25} {username:<20} {time_str:<20}"
                    
                    print(line_data) # Print to console
                    f.write(line_data + "\n") # Write to file
                    
                    current = current.next
                    idx += 1
                
                print(separator)
                f.write(separator + "\n")
            print(f"\nâœ… Laporan berhasil disimpan ke {report_file_name}\n")
        except IOError:
            print(f"\nâŒ Gagal menulis laporan ke file {report_file_name}.\n")


    def cari_nama_orang_antre(self, nama_username_to_find): # Can be username
        current = self.antrian.front
        posisi = 1
        while current:
            username_in_queue = current.data[0]
            if username_in_queue == nama_username_to_find:
                display_name = get_display_name(username_in_queue)
                print(f"Pengguna {display_name} ({username_in_queue}) ditemukan pada antrean nomor {posisi}.")
                return
            current = current.next
            posisi +=1
        print(f"Pengguna {nama_username_to_find} tidak ditemukan dalam antrean.")

    def update_antrean(self, index1, index2, actor_username, actor_role): # Added actor info
        all_data_tuples = self.antrian.get_all_items_with_timestamps()

        if not (0 <= index1 < len(all_data_tuples) and 0 <= index2 < len(all_data_tuples)):
            print("Indeks tidak valid!")
            return

        user1_tuple = all_data_tuples[index1]
        user2_tuple = all_data_tuples[index2]

        # Swap
        all_data_tuples[index1], all_data_tuples[index2] = all_data_tuples[index2], all_data_tuples[index1]

        # Rebuild antrean
        self.antrian = LinkedListQueue() # Clear current queue
        for item_tuple in all_data_tuples:
            # Enqueue with original item and its original timestamp
            self.antrian.enqueue(item_tuple[0], timestamp=item_tuple[1])

        user1_display = get_display_name(user1_tuple[0])
        user2_display = get_display_name(user2_tuple[0])
        print(f"Urutan antrean {user1_display} dan {user2_display} berhasil ditukar.")
        self.save_antrian()
        log_activity(actor_username, actor_role, "Tukar posisi antrean", f"Antara {user1_tuple[0]} dan {user2_tuple[0]}")